/*# P8671 [蓝桥杯 2018 国 AC] 约瑟夫环

## 题目描述

$n$ 个人的编号是 $1 \sim n$，如果他们依编号按顺时针排成一个圆圈，从编号是 $1$ 的人开始顺时针报数。

（报数是从 $1$ 报起）当报到 $k$ 的时候，这个人就退出游戏圈。下一个人重新从 $1$ 开始报数。

求最后剩下的人的编号。这就是著名的约瑟夫环问题。

本题目就是已知 $n$，$k$ 的情况下，求最后剩下的人的编号。

## 输入格式

题目的输入是一行，$2$ 个空格分开的整数 $n,k$。

## 输出格式

要求输出一个整数，表示最后剩下的人的编号。

## 输入输出样例 #1

### 输入 #1

```
10 3
```

### 输出 #1

```
4
```

## 说明/提示

$0<n,k<10^6$。

时限 1 秒, 256M。蓝桥杯 2018 年第九届国赛*/


//version 1:超时
// #include<stdio.h>
// #define N 1000005
// int a[N];
// int main()
// {
//     int n,k;
//     scanf("%d%d",&n,&k);
//     for(int i=1;i<=n;i++)
//         a[i]=1;
//     int cnt=0,i=0,kill=0;
//     while(cnt<n-1)//当心这里不是n
//     {
//         //去掉n-1个人
//         /*1 1 1 1 1 1 1 
//           1 -1  
//           */
//         //每k个去掉一个
//         //用%的方式实现环
//         if(a[i%n+1]==1&&kill<k-1) //注意这里是k-1
//         {
//             kill++;
//             i++;
//         }
//         //i%n的索引是0--n-1
//         else if(a[i%n+1]==1&&kill==k-1){
//             a[i%n+1]  = 0;
//             kill=0;
//             cnt++;
//             i++;
//         }
//         else{
//             i++;
//         }
//     }
//     int ans;
//     for(int j=1;j<=n;j++)
//         if(a[j]==1) ans=j;
//     printf("%d",ans);
// }



//version2:不用遍历每一个

//模拟法在 n=1e6 时会超时（尤其是 k 很大时），约瑟夫环有经典递推公式，核心思路是从最后 1 人的位置倒推;

#include<stdio.h>

int main() {
    int n, k;
    scanf("%d%d", &n, &k);
    
    int res = 1;  
    // 从2人递推到n人
    for (int i = 2; i <= n; i++) {
        res = (res + k) % i;
    }
    // 转换为1~n的编号
    printf("%d\n", res);
    
    return 0;
}
/*有的时候不要一上来就想着模拟
  可以考虑递推
  从做数学实验开始 10 3
  1 2 3 4 5 6 7 8 9 10*/